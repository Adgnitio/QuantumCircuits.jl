var documenterSearchIndex = {"docs":
[{"location":"QML/CircuitOptimization/#QuantumCircuits.QML.CircuitOptimization","page":"Gates","title":"QuantumCircuits.QML.CircuitOptimization","text":"","category":"section"},{"location":"QML/CircuitOptimization/","page":"Gates","title":"Gates","text":"Modules = [QuantumCircuits.QML.CircuitOptimization]","category":"page"},{"location":"Simulation/Trotterization/#Novel-algorithm-to-Simulation-on-NISQ-device","page":"Algorithm description","title":"1 Novel algorithm to Simulation on NISQ device","text":"","category":"section"},{"location":"Simulation/Trotterization/","page":"Algorithm description","title":"Algorithm description","text":"using QuantumCircuits\nusing QuantumCircuits.QML\nusing QuantumCircuits.QCircuits.Qiskit\nusing QuantumCircuits.QCircuits.Qiskit: qiskit\nusing QuantumCircuits.QCircuits.Circuit\nusing QuantumCircuits.QCircuits.Circuit: toQiskit, getCode\nusing QuantumCircuits.QCircuits.Gates: CX\nusing QuantumCircuits.Execute: generate_mesuere_circuits, extractProbability, correctMeasures","category":"page"},{"location":"Simulation/Trotterization/#Introduction","page":"Algorithm description","title":"2 Introduction","text":"","category":"section"},{"location":"Simulation/Trotterization/","page":"Algorithm description","title":"Algorithm description","text":"Our goal is to implement the Trotterization to evolve the specified state 110rangle, under the specified Hamiltonian, for the specified duration pi but utilize as many Trotter steps as is possible. The algorithm, in principle, should be executed for any state, Hamiltonian, and duration.","category":"page"},{"location":"Simulation/Trotterization/","page":"Algorithm description","title":"Algorithm description","text":"Unfortunately on the current quantum computer, this is impossible regarding the noises. Therefore I've proposed an algorithm that can break the Trotterization into pieces with a shorter depth which can be executed on current quantum computers. The main points and requirements of the algorithm:","category":"page"},{"location":"Simulation/Trotterization/","page":"Algorithm description","title":"Algorithm description","text":"It breaks the Trotterization into pieces with a shorter depth.\nIt is convergent to the final state.\nThe designed algorithm should allow us to find the simulated state for an arbitrary number of qubits.","category":"page"},{"location":"Simulation/Trotterization/","page":"Algorithm description","title":"Algorithm description","text":"The first stage is to find a way how to effectively implement a trotter step, the details of that can be found in  Cartan's KAK decomposition. ","category":"page"},{"location":"Simulation/Trotterization/#The-overview-of-algorithm","page":"Algorithm description","title":"3 The overview of algorithm","text":"","category":"section"},{"location":"Simulation/Trotterization/","page":"Algorithm description","title":"Algorithm description","text":"Let's assume, that we would like to implement an algorithm with 10 Trotter steps, but using at most 2 Trotter steps in single circuit execution. We can do this by implementing the circuit below and using the gradient descent method to find the parameters theta_1 that minimize our cost function. The cost function is chosen that after finding the optimal parameters the output status is 0rangle_3. Why I use 000rangle as a target state, there are a few reasons:","category":"page"},{"location":"Simulation/Trotterization/","page":"Algorithm description","title":"Algorithm description","text":"We need to avoid any superposition and use only base state 000rangle, 001rangle, eg. Using superposition implies variance > 0 during expectation measurement even on the perfect device, for the base state the variance is equal to 0. This is important because any fluctuation impact derivative calculation using the shift-parameter rule.\nThe 000rangle state in natural choice because this is the starting point for quantum device.","category":"page"},{"location":"Simulation/Trotterization/","page":"Algorithm description","title":"Algorithm description","text":"First, we would like to fit the expected distribution. The use of entropy loos is a natural choice point. In our case, the expected distribution has only one non zero value for state 000, so the entropy loss looks like: -lnP(000rangle) But the other requirement is that the error for the other state should be equally distributed, so we prefer frac001rangle + 010ranglesqrt2 to 001rangle but the entropy for both of the states is equal. Therefore our loss function is equal to: -lnP(000rangle) + sum_i = 001rangle^111rangleP(i)^2 (see Algorithm evaluation)","category":"page"},{"location":"Simulation/Trotterization/","page":"Algorithm description","title":"Algorithm description","text":"(Image: image)","category":"page"},{"location":"Simulation/Trotterization/","page":"Algorithm description","title":"Algorithm description","text":"If the optimal parameters were found, the operator inverse of Ansact transform the initial state into the state after the initialization and the two trotter steps. ","category":"page"},{"location":"Simulation/Trotterization/","page":"Algorithm description","title":"Algorithm description","text":"Is worth noting that: if any circuit T transforms the initial state 000rangle into some state psi,  and we find any other A circuit that transforms state psi into the 000rangle one we know that the inverse of the A circuit creates the state psi from state 000rangle with accuracy to global phase (which is irrelevant and can be omitted). Note, that circuits A and T are not equivalent (so they unitary may not and usually are not equal), but this is ok for us we only would like to transform the given input state to the given output. And because these unitaries don't have to be equal, it is easy to prepare ansact and find the best parameters.","category":"page"},{"location":"Simulation/Trotterization/","page":"Algorithm description","title":"Algorithm description","text":"So the circuits on figure below are equivalent.","category":"page"},{"location":"Simulation/Trotterization/","page":"Algorithm description","title":"Algorithm description","text":"(Image: image)","category":"page"},{"location":"Simulation/Trotterization/","page":"Algorithm description","title":"Algorithm description","text":"In the Figure below, you can find the ansact with 27 parameters used in the algorithm implementation.","category":"page"},{"location":"Simulation/Trotterization/","page":"Algorithm description","title":"Algorithm description","text":"(Image: ansact.jpg)","category":"page"},{"location":"Simulation/Trotterization/","page":"Algorithm description","title":"Algorithm description","text":"It is worth noting:","category":"page"},{"location":"Simulation/Trotterization/","page":"Algorithm description","title":"Algorithm description","text":"We are not looking for parameters that implement the whole unitary matrix of the 2 Trotter steps with the greatest accuracy, but only a transformation for a specific input state. This implies that it is relatively easy to find these parameters. \nUsing the ansact, we can replace the circuit with 15 CNOT gates with the one with only 4 CNOT gates.\nI use exactly the same ansact for all iterations but when can have different ansacts for other iterations.","category":"page"},{"location":"Simulation/Trotterization/#.1-Next-step","page":"Algorithm description","title":"3.1 Next step","text":"","category":"section"},{"location":"Simulation/Trotterization/","page":"Algorithm description","title":"Algorithm description","text":"Then we do a similar step and try to find the parameters theta_2 using the gradient descent method that make the circuit in the Figure below will finish at state 0rangle_3.","category":"page"},{"location":"Simulation/Trotterization/","page":"Algorithm description","title":"Algorithm description","text":"(Image: image)","category":"page"},{"location":"Simulation/Trotterization/","page":"Algorithm description","title":"Algorithm description","text":"If the optimal parameters theta_2 were found, the operator inverse of Ansact transform the initial state into the state after the initialization and the 4 trotter steps. So the circuits on Figure below are equivalent.","category":"page"},{"location":"Simulation/Trotterization/","page":"Algorithm description","title":"Algorithm description","text":"(Image: image)","category":"page"},{"location":"Simulation/Trotterization/","page":"Algorithm description","title":"Algorithm description","text":"By continuing this algorithm finally, we can find the parameters which implement the whole Trotterization, see Figure below.","category":"page"},{"location":"Simulation/Trotterization/","page":"Algorithm description","title":"Algorithm description","text":"(Image: image)","category":"page"},{"location":"Simulation/Trotterization/#.2-Result-evaluation","page":"Algorithm description","title":"3.2 Result evaluation","text":"","category":"section"},{"location":"Simulation/Trotterization/","page":"Algorithm description","title":"Algorithm description","text":"I've evaluated the algorithm on the simulator with time set to fracpi4, fracpi2, frac3pi4, pi and it works fine. So this show that it will work not only for the special case where the whole circuit is identity. The evaluation can be found in the notebook Algorithm evaluation","category":"page"},{"location":"Simulation/Trotterization/#.3-Trening","page":"Algorithm description","title":"3.3 Trening","text":"","category":"section"},{"location":"Simulation/Trotterization/","page":"Algorithm description","title":"Algorithm description","text":"I've also find the parameters theta_1 of the first step on quantum computer (ibm jakarta).The parameter for steps from 2 to 5 (theta_2 theta_3 theta_4 theta_5) was found on the noisy quantum simulator (as was discussed with AJ). Description of the process of finding the parameter is described in a notebook QML Trening.","category":"page"},{"location":"Simulation/Trotterization/#Execute-on-the-real-device","page":"Algorithm description","title":"4 Execute on the real device","text":"","category":"section"},{"location":"Simulation/Trotterization/","page":"Algorithm description","title":"Algorithm description","text":"The whole solution using QuantumCircuits library is available in GitHub.","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/#Cartan's-KAK-decomposition","page":"U4 - Cartan's KAK decomposition","title":"1 Cartan's KAK decomposition","text":"","category":"section"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"We want to implement the trotter step in an effective way, but a naive implementation of ZZ, XX, and YY gates requires 6 CX gates. We will show how to do the same using only the 3CX gate by Cartan's KAK decomposition.","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/#ZZ,-XX,-and-YY-gates","page":"U4 - Cartan's KAK decomposition","title":"2 ZZ, XX, and YY gates","text":"","category":"section"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"Now we have to create ZZ, XX, and YY gates for use in simulation.","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"using QuantumCircuits\nusing QuantumCircuits.QML\nusing QuantumCircuits.QCircuits.Qiskit\nusing QuantumCircuits.QCircuits.Qiskit: qiskit\nusing QuantumCircuits.QCircuits.Circuit\nusing QuantumCircuits.QCircuits.Circuit: toQiskit, getCode\nusing QuantumCircuits.QCircuits.Gates: CX\nusing QuantumCircuits.Execute: generate_mesuere_circuits, extractProbability, correctMeasures","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"# This code com from using QuantumCircuits.Simulation.Gates module.\nfunction ZZ(qc, q0, q1, t, usePulse=false)\n    if usePulse\n        qc.h(q1)\n        qc.rzx(q0, q1, t)\n        qc.x(q0)\n        qc.rzx(q0, q1, -t)\n        qc.x(q0)\n        qc.h(q1)\n    else\n        qc.cx(q0, q1)\n        qc.rz(q1, 2*t)\n        qc.cx(q0, q1)\n    end\nend\n\nfunction YY(qc, q0, q1, t, usePulse=false)\n    if usePulse\n        qc.sdg([q0, q1])\n        qc.h(q0)\n        qc.rzx(q0, q1, t)\n        qc.x(q0)\n        qc.rzx(q0, q1, -t)\n        qc.x(q0)\n        qc.h(q0)\n        qc.s([q0, q1])\n    else\n        qc.rx([q0, q1], π/2)\n        qc.cx(q0, q1)\n        qc.rz(q1, 2*t)\n        qc.cx(q0, q1)\n        qc.rx([q0, q1], -π/2)\n    end\nend\n\nfunction XX(qc, q0, q1, t, usePulse=false)\n    if usePulse\n        qc.h(q0)\n        qc.rzx(q0, q1, t)\n        qc.x(q0)\n        qc.rzx(q0, q1, -t)\n        qc.x(q0)\n        qc.h(q0)\n    else\n        qc.ry([q0, q1], π/2)\n        qc.cx(q0, q1)\n        qc.rz(q1, 2*t)\n        qc.cx(q0, q1)\n        qc.ry([q0, q1], -π/2)\n    end\nend","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/#U4-Cartan's-KAK-decomposition","page":"U4 - Cartan's KAK decomposition","title":"3 U4 - Cartan's KAK decomposition","text":"","category":"section"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"Any 2 qubits unitary can be decomposed used 3 cx gate (see the paper \"Minimal Universal Two-qubit Quantum Circuits\" https://arxiv.org/abs/quant-ph/0308033). In QuantumCircuits library we have defined the U4 gate.","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"qc = QCircuit(2)\n# Create u4 gate with random parameter\nqc.u4(0, 1) \n\n# Decompose circuit to use base gates\nqc2 = decompose(qc)\nqc2","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"      ┌──────────────────────────┐┌───┐┌────────────┐                   ┌───┐»\nq0_0: ┤ U3(2.2832,4.3098,1.6032) ├┤ X ├┤ Rz(3.6536) ├──■────────────────┤ X ├»\n      ├─────────────────────────┬┘└─┬─┘├────────────┤┌─┴─┐┌────────────┐└─┬─┘»\nq0_1: ┤ U3(4.263,1.3415,2.3539) ├───■──┤ Ry(5.2857) ├┤ X ├┤ Ry(4.1467) ├──■──»\n      └─────────────────────────┘      └────────────┘└───┘└────────────┘     »\nc0: 2/═══════════════════════════════════════════════════════════════════════»\n                                                                             »\n«      ┌────────────────────────────┐\n«q0_0: ┤ U3(3.4384,0.79627,0.14553) ├\n«      └┬──────────────────────────┬┘\n«q0_1: ─┤ U3(4.9937,3.1561,5.6151) ├─\n«       └──────────────────────────┘ \n«c0: 2/══════════════════════════════\n«                                    ","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"Let us assume that we would like to find parameters of the U4 gate implementing exactly ZZ, YY, and XX gate combinations for a given time t.","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"t = π/2\n\nqc = QCircuit(2)\nZZ(qc, 0, 1, t)\nYY(qc, 0, 1, t)\nXX(qc, 0, 1, t)\nexpmat = tomatrix(qc)\nqc","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"                         ┌─────────┐                   ┌──────────┐┌─────────┐»\nq1_0: ──■─────────────■──┤ Rx(π/2) ├──■─────────────■──┤ Rx(-π/2) ├┤ Ry(π/2) ├»\n      ┌─┴─┐┌───────┐┌─┴─┐├─────────┤┌─┴─┐┌───────┐┌─┴─┐├──────────┤├─────────┤»\nq1_1: ┤ X ├┤ Rz(π) ├┤ X ├┤ Rx(π/2) ├┤ X ├┤ Rz(π) ├┤ X ├┤ Rx(-π/2) ├┤ Ry(π/2) ├»\n      └───┘└───────┘└───┘└─────────┘└───┘└───────┘└───┘└──────────┘└─────────┘»\nc1: 2/════════════════════════════════════════════════════════════════════════»\n                                                                              »\n«                         ┌──────────┐\n«q1_0: ──■─────────────■──┤ Ry(-π/2) ├\n«      ┌─┴─┐┌───────┐┌─┴─┐├──────────┤\n«q1_1: ┤ X ├┤ Rz(π) ├┤ X ├┤ Ry(-π/2) ├\n«      └───┘└───────┘└───┘└──────────┘\n«c1: 2/═══════════════════════════════\n«                                     ","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"We have to choose the ansact, in our case this will be a U4 gate and in that case, we are sure that we always can find the correct parameters.","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"qr = QuantumRegister(2)\nqc = QCircuit(qr)\nqc.u4(qr[0], qr[1])\n\nparams = getRandParameters(qc)\nsetparameters!(qc, params)\nqc = decompose(qc)","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"      ┌───────────────────────────┐┌───┐┌────────────┐                   ┌───┐»\nq2_0: ┤ U3(1.7624,0.77116,3.9005) ├┤ X ├┤ Rz(5.2775) ├──■────────────────┤ X ├»\n      └┬──────────────────────────┤└─┬─┘├────────────┤┌─┴─┐┌────────────┐└─┬─┘»\nq2_1: ─┤ U3(5.0677,5.7902,6.2463) ├──■──┤ Ry(4.4635) ├┤ X ├┤ Ry(2.5877) ├──■──»\n       └──────────────────────────┘     └────────────┘└───┘└────────────┘     »\n«      ┌──────────────────────────┐\n«q2_0: ┤ U3(0.89282,1.8969,3.728) ├\n«      ├──────────────────────────┤\n«q2_1: ┤ U3(4.2926,2.4936,2.6366) ├\n«      └──────────────────────────┘","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"Now we can find the parameter of our ansact that perfectly fit our expected unitary matrix.","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"params, _, err, _  = findparam(expmat, qc, debug=false, trystandard=false)\nerr","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"8.988143676440324e-8","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"qc","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"      ┌──────────────────────────┐┌───┐┌──────────┐                ┌───┐»\nq3_0: ┤ U3(1.4791,0.48683,4.394) ├┤ X ├┤ Rz(3π/2) ├──■─────────────┤ X ├»\n      └─┬─────────────────────┬──┘└─┬─┘├──────────┤┌─┴─┐┌─────────┐└─┬─┘»\nq3_1: ──┤ U3(π,5.7747,5.1031) ├─────■──┤ Ry(3π/2) ├┤ X ├┤ Ry(π/2) ├──■──»\n        └─────────────────────┘        └──────────┘└───┘└─────────┘     »\n«      ┌───────────────────────────┐\n«q3_0: ┤ U3(-1.4791,1.8894,4.2257) ├\n«      └──┬─────────────────────┬──┘\n«q3_1: ───┤ U3(π,1.9652,2.8646) ├───\n«         └─────────────────────┘   ","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"A description of the optimization method used is available in the notebook Eva.","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/#The-effective-implementation-of-the-Trotter-step","page":"U4 - Cartan's KAK decomposition","title":"4  The effective implementation of the Trotter step","text":"","category":"section"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"Assume that we would like to implement the Trotter step using the second-order Trotter formula (see \"Quantum computers as universal quantum simulators: state-of-art and perspectives\" https://arxiv.org/abs/1907.03505), we can do this using the circuit in below.","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"(Image: image)","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"Using Cartan's KAK decomposition we can rewrite this circuit and replace ZZ, YY, and XX by singe U4 gate as in Figure below.","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"(Image: image)","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"Assume that we would like to implement the 2 Trotter step using the second-order Trotter formula. Using Cartan's KAK decomposition each step contains 3 U4 gates. But merging the two U4 gates on qubits 0 and 1, the two steps of the Trotter formula using KAK decomposition look like in the Figure below. It's worth noting that these two steps of Trotter utilize only 15 CNOT gates (3 CNOT for each of the U4 gates).","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"(Image: image)","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"Effective implementation of the two steps is important because this is how much we use in the model training process (see Algorithm evaluation). However, a similar method of connecting two U4 gates can be used for any number of steps. ","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/#Simulation","page":"U4 - Cartan's KAK decomposition","title":"5 Simulation","text":"","category":"section"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"First we create helper function which find the parameter for U4 for ZZ, YY, and XX gates and ZZ, YY, XX, ZZ, YY and, XX and Trotter step.","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"# This code com from using QuantumCircuits.Simulation.Gates module.\nfunction findU4paramsZZYYXX(t; debug=false)\n    qc = QCircuit(2)\n    ZZ(qc, 0, 1, t)\n    YY(qc, 0, 1, t)\n    XX(qc, 0, 1, t)\n    expmat = tomatrix(qc)\n\n\n    qr = QuantumRegister(2)\n    qc = QCircuit(qr)\n    qc.u4(qr[0], qr[1])\n\n    params = getRandParameters(qc)\n    setparameters!(qc, params)\n    qc = decompose(qc)\n\n    params, _, err, _  = findparam(expmat, qc, debug=debug, trystandard=false)\n\n    @assert err < 1e-5 \"The error of U gate should be small but it is $err.\"\n\n    return params\nend\n\nfunction findU4paramsZZYYXXx2(t; debug=false)\n    qc = QCircuit(2)\n    ZZ(qc, 0, 1, t)\n    YY(qc, 0, 1, t)\n    XX(qc, 0, 1, t)\n    ZZ(qc, 0, 1, t)\n    YY(qc, 0, 1, t)\n    XX(qc, 0, 1, t)\n    expmat = tomatrix(qc)\n\n\n    qr = QuantumRegister(2)\n    qc = QCircuit(qr)\n    qc.u4(qr[0], qr[1])\n\n    params = getRandParameters(qc)\n    setparameters!(qc, params)\n    qc = decompose(qc)\n\n    params, _, err, _  = findparam(expmat, qc, debug=debug, trystandard=false)\n    @assert err < 1e-5 \"The error of U gate should be small but it is $err.\"\n\n    return params\nend\n\nfunction trotter2U4(qc, qubits, t, isFirst, isLast, params, params2, params3)\n    if isFirst\n        for i in 1:(length(qubits)-2)\n            qc.u4(qubits[i], qubits[i+1], params2)\n        end\n    end\n\n    i = length(qubits) - 1\n    qc.u4(qubits[i], qubits[i+1], params)\n\n    if isLast\n        for i in 1:(length(qubits)-2)\n            qc.u4(qubits[i], qubits[i+1], params2)\n        end\n    else\n        for i in 1:(length(qubits)-2)\n            qc.u4(qubits[i], qubits[i+1], params3)\n        end\n    end\nend","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"Next function generate circuit of the simulation algorithm for given Trotter steps number.","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"function generate_circuit(trotter_steps, run_step, t=π, params=nothing, params2=nothing, params3=nothing; init=false, debug=false)\n    qr = QuantumRegister(7, \"q\")\n    qc = QCircuit(qr)\n\n    # Prepare initial state (remember we are only evolving 3 of the 7 qubits on jakarta qubits (q_5, q_3, q_1) corresponding to the state |110>)\n    if init\n        qc.x([3, 5])  # DO NOT MODIFY (|q_5,q_3,q_1> = |110>)\n    end\n\n    if params == nothing\n        params = findU4paramsZZYYXX(t / trotter_steps, debug=debug)\n        params2 = findU4paramsZZYYXX(t / (2 * trotter_steps), debug=debug)\n        params3 = findU4paramsZZYYXXx2(t / (2 * trotter_steps), debug=debug)\n    end\n\n    qubits = [qr[1], qr[3], qr[5]]\n    for s in 1:run_step\n        isFirst = s == 1\n        isLast = s == run_step\n\n        trotter2U4(qc, qubits, t / trotter_steps, isFirst, isLast, params, params2, params3)\n    end\n\n    qc = decompose(qc)\n    return qc, params, params2, params3\nend","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"Now we can generate the circuit.","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"t = π\ntrotter_steps = 10\nqc_full, _, _, _ = generate_circuit(trotter_steps, trotter_steps, t, init=true)\n\n# Add measurment\ncr = ClassicalRegister(3)\nsetClassicalRegister!(qc_full, cr)\nqc_full.measure([1, 3, 5], [0, 1, 2])\nqc_full","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"q_0: ─────────────────────────────────────────────────────────────────────────»\n      ┌────────────────────────┐                              ┌───┐┌──────────┐»\n q_1: ┤ U3(2π,5.3676,0.032489) ├──────────────────────────────┤ X ├┤ Rz(7π/5) ├»\n      └────────────────────────┘                              └─┬─┘└──────────┘»\n q_2: ──────────────────────────────────────────────────────────┼──────────────»\n                ┌───┐             ┌────────────────────────┐    │  ┌──────────┐»\n q_3: ──────────┤ X ├─────────────┤ U3(-π,0.70057,-1.7539) ├────■──┤ Ry(7π/5) ├»\n                └───┘             └────────────────────────┘       └──────────┘»\n q_4: ─────────────────────────────────────────────────────────────────────────»\n                ┌───┐           ┌────────────────────────────┐                 »\n q_5: ──────────┤ X ├───────────┤ U3(3.1416,3.5375,-0.46269) ├─────────────────»\n                └───┘           └────────────────────────────┘                 »\n q_6: ─────────────────────────────────────────────────────────────────────────»\n                                                                               »\nc2: 3/═════════════════════════════════════════════════════════════════════════»\n                                                                               »\n«                                                       »\n« q_0: ─────────────────────────────────────────────────»\n«                        ┌───┐ ┌─────────────────────┐  »\n« q_1: ──■───────────────┤ X ├─┤ U3(0,5.1954,6.6832) ├──»\n«        │               └─┬─┘ └─────────────────────┘  »\n« q_2: ──┼─────────────────┼────────────────────────────»\n«      ┌─┴─┐┌───────────┐  │  ┌────────────────────────┐»\n« q_3: ┤ X ├┤ Ry(12π/5) ├──■──┤ U3(π,0.96835,0.084917) ├»\n...\n«                                                                    ║  ║ \n« q_6: ──────────────────────────────────────────────────────────────╫──╫─\n«                                                                    ║  ║ \n«c2: 3/══════════════════════════════════════════════════════════════╩══╩═\n«                                                                    0  1 ","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"Next helper function is used to compare the simulation results with  exact values.","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"using QuantumCircuits.QCircuits.Math\nusing QuantumCircuits.QCircuits.Gates: Xmatrix, Ymatrix, Zmatrix\n\nXXs = kron(kron(eye(2), Xmatrix), Xmatrix) + kron(kron(Xmatrix, Xmatrix), eye(2))\nYYs = kron(kron(eye(2), Ymatrix), Ymatrix) + kron(kron(Ymatrix, Ymatrix), eye(2))\nZZs = kron(kron(eye(2), Zmatrix), Zmatrix) + kron(kron(Zmatrix, Zmatrix), eye(2))\nHs = XXs + YYs + ZZs\n\nU_heis3(t) = exp(-im * Hs * t)\n\nconst backend = QuantumSimulator()\n\nfunction check_simulation_err(qc, t)\n    sym_full = execute(backend, qc)\n    exp_full = U_heis3(t) * ket\"110\"\n    exp_full = abs.(exp_full) .^ 2\n    return sum(abs.(sym_full - exp_full))\nend","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"And, now we can check the results.","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"check_simulation_err(qc_full, t)","category":"page"},{"location":"Simulation/U4_Cartan_decomposition/","page":"U4 - Cartan's KAK decomposition","title":"U4 - Cartan's KAK decomposition","text":"0.102783108661551","category":"page"},{"location":"1_Two-qubit-gates/#Quantum-Circuits-Library:-Two-qubit-gates","page":"Two-qubit gates","title":"Quantum Circuits Library: Two-qubit gates","text":"","category":"section"},{"location":"1_Two-qubit-gates/","page":"Two-qubit gates","title":"Two-qubit gates","text":"CurrentModule = QuantumCircuits.QCircuits.Gates","category":"page"},{"location":"1_Two-qubit-gates/#CX","page":"Two-qubit gates","title":"CX","text":"","category":"section"},{"location":"1_Two-qubit-gates/","page":"Two-qubit gates","title":"Two-qubit gates","text":"CX","category":"page"},{"location":"1_Two-qubit-gates/#QuantumCircuits.QCircuits.Gates.CX","page":"Two-qubit gates","title":"QuantumCircuits.QCircuits.Gates.CX","text":"CX(control::Qubit, target::Qubit)\n\nTwo-qubit controlled NOT gate with control and target on first and second qubits, respectively. This is also  called the controlled X gate.  Circuit Representation\n\nq_0: ──■──\n     ┌─┴─┐\nq_1: ┤ X ├\n     └───┘\n\nMatrix Representation\n\nCX = beginpmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  0  1 \n    0  0  1  0\n    endpmatrix\n\nqc = QCircuit(2)\nqc.cx(0, 1)\n\n\n\n\n\n","category":"type"},{"location":"QCircuits/OtherGates/#QuantumCircuits.OtherGates","page":"OtherGates","title":"QuantumCircuits.OtherGates","text":"","category":"section"},{"location":"QCircuits/OtherGates/","page":"OtherGates","title":"OtherGates","text":"Modules = [QuantumCircuits.QCircuits.OtherGates]","category":"page"},{"location":"QCircuits/OtherGates/#QuantumCircuits.QCircuits.OtherGates.TwoQubitsRotationGate","page":"OtherGates","title":"QuantumCircuits.QCircuits.OtherGates.TwoQubitsRotationGate","text":"Rotation gates\n\n\n\n\n\n","category":"type"},{"location":"QCircuits/OtherGates/#QuantumCircuits.QCircuits.Gates.getqubits-Tuple{QuantumCircuits.QCircuits.OtherGates.TwoQubitsRotationGate}","page":"OtherGates","title":"QuantumCircuits.QCircuits.Gates.getqubits","text":"Return the qubits on which operate the gate\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/OtherGates/#QuantumCircuits.QCircuits.Gates.getqubitsids-Tuple{QuantumCircuits.QCircuits.OtherGates.TwoQubitsRotationGate}","page":"OtherGates","title":"QuantumCircuits.QCircuits.Gates.getqubitsids","text":"Return the qubits ids on which operate the gate\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/OtherGates/#QuantumCircuits.QCircuits.OtherGates.@twoQubitsRotationGate-Tuple{Any}","page":"OtherGates","title":"QuantumCircuits.QCircuits.OtherGates.@twoQubitsRotationGate","text":"Rotation macro\n\n\n\n\n\n","category":"macro"},{"location":"QCircuits/Qiskit/#QuantumCircuits.QCircuits.Qiskit","page":"Qiskit","title":"QuantumCircuits.QCircuits.Qiskit","text":"","category":"section"},{"location":"QCircuits/Qiskit/","page":"Qiskit","title":"Qiskit","text":"Modules = [QuantumCircuits.QCircuits.Qiskit]","category":"page"},{"location":"QCircuits/Qiskit/#QuantumCircuits.QCircuits.Qiskit.NoQiskitError","page":"Qiskit","title":"QuantumCircuits.QCircuits.Qiskit.NoQiskitError","text":"The error throw when there is no qiskit instaled.\n\n\n\n\n\n","category":"type"},{"location":"QCircuits/Qiskit/#QuantumCircuits.QCircuits.Qiskit.QiskitCircuit","page":"Qiskit","title":"QuantumCircuits.QCircuits.Qiskit.QiskitCircuit","text":"Quantum circuit provided by Qiskit.\n\n\n\n\n\n","category":"type"},{"location":"QCircuits/Qiskit/#QuantumCircuits.QCircuits.Qiskit.QiskitDevice","page":"Qiskit","title":"QuantumCircuits.QCircuits.Qiskit.QiskitDevice","text":"Quantum device provided by Qiskit.\n\n\n\n\n\n","category":"type"},{"location":"QCircuits/Qiskit/#QuantumCircuits.QCircuits.Qiskit.QiskitSimulator","page":"Qiskit","title":"QuantumCircuits.QCircuits.Qiskit.QiskitSimulator","text":"Qiskit simulator\n\n\n\n\n\n","category":"type"},{"location":"QCircuits/Qiskit/#Base.show-Tuple{IO, QuantumCircuits.QCircuits.Qiskit.QiskitCircuit}","page":"Qiskit","title":"Base.show","text":"Show method\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Qiskit/#QuantumCircuits.QCircuits.QBase.add!-Tuple{QuantumCircuits.QCircuits.Qiskit.QiskitCircuit, QuantumGate}","page":"Qiskit","title":"QuantumCircuits.QCircuits.QBase.add!","text":"Add gate to circuit\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Qiskit/#QuantumCircuits.QCircuits.QBase.tomatrix-Tuple{QuantumCircuits.QCircuits.Qiskit.QiskitCircuit}","page":"Qiskit","title":"QuantumCircuits.QCircuits.QBase.tomatrix","text":"Get the matrix version of the cirquit.\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Qiskit/#QuantumCircuits.QCircuits.Qiskit.addQiskitCode-Tuple{QuantumCircuits.QCircuits.Qiskit.QiskitCircuit, QuantumCircuits.QCircuits.Gates.X}","page":"Qiskit","title":"QuantumCircuits.QCircuits.Qiskit.addQiskitCode","text":"Add quantum gate to Qiskit circuit\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Qiskit/#QuantumCircuits.QCircuits.Qiskit.draw-Tuple{QuantumCircuits.QCircuits.Qiskit.QiskitCircuit}","page":"Qiskit","title":"QuantumCircuits.QCircuits.Qiskit.draw","text":"Draw the circuit.\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Qiskit/#QuantumCircuits.QCircuits.Qiskit.getQRegister-Tuple{QuantumCircuits.QCircuits.Qiskit.QiskitCircuit, AbstractString}","page":"Qiskit","title":"QuantumCircuits.QCircuits.Qiskit.getQRegister","text":"Function return the register\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Qiskit/#QuantumCircuits.QCircuits.Qiskit.nop","page":"Qiskit","title":"QuantumCircuits.QCircuits.Qiskit.nop","text":"Nothing function\n\n\n\n\n\n","category":"function"},{"location":"QML/QML/#QuantumCircuits.QML","page":"QML","title":"QuantumCircuits.QML","text":"","category":"section"},{"location":"QML/QML/","page":"QML","title":"QML","text":"Modules = [QuantumCircuits.QML]","category":"page"},{"location":"QML/QML/#QuantumCircuits.QML","page":"QML","title":"QuantumCircuits.QML","text":"Quantum machine learning\n\n\n\n\n\n","category":"module"},{"location":"QCircuits/Instructions/#QuantumCircuits.QCircuits.Instructions","page":"Instructions","title":"QuantumCircuits.QCircuits.Instructions","text":"","category":"section"},{"location":"QCircuits/Instructions/","page":"Instructions","title":"Instructions","text":"Modules = [QuantumCircuits.QCircuits.Instructions]","category":"page"},{"location":"QCircuits/Instructions/#QuantumCircuits.QCircuits.Instructions.Barrier","page":"Instructions","title":"QuantumCircuits.QCircuits.Instructions.Barrier","text":"Universary two qubits gate.\n\n\n\n\n\n","category":"type"},{"location":"QCircuits/Instructions/#QuantumCircuits.QCircuits.Gates.getqubits-Tuple{QuantumCircuits.QCircuits.Instructions.Barrier}","page":"Instructions","title":"QuantumCircuits.QCircuits.Gates.getqubits","text":"Return the qubits on which operate the gate\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Instructions/#QuantumCircuits.QCircuits.Gates.getqubitsids-Tuple{QuantumCircuits.QCircuits.Instructions.Barrier}","page":"Instructions","title":"QuantumCircuits.QCircuits.Gates.getqubitsids","text":"Return the qubits ids on which operate the gate\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Instructions/#QuantumCircuits.QCircuits.QBase.simplify-Tuple{QuantumCircuits.QCircuits.Instructions.Barrier}","page":"Instructions","title":"QuantumCircuits.QCircuits.QBase.simplify","text":"The simplify the gates.\n\n\n\n\n\n","category":"method"},{"location":"0_Single-qubit-gates/#Quantum-Circuits-Library:-Single-qubit-gates","page":"Single-qubit gates s","title":"Quantum Circuits Library: Single-qubit gates","text":"","category":"section"},{"location":"0_Single-qubit-gates/","page":"Single-qubit gates s","title":"Single-qubit gates s","text":"CurrentModule = QuantumCircuits.QCircuits.Gates","category":"page"},{"location":"0_Single-qubit-gates/#U3","page":"Single-qubit gates s","title":"U3","text":"","category":"section"},{"location":"0_Single-qubit-gates/","page":"Single-qubit gates s","title":"Single-qubit gates s","text":"U3","category":"page"},{"location":"0_Single-qubit-gates/#QuantumCircuits.QCircuits.Gates.U3","page":"Single-qubit gates s","title":"QuantumCircuits.QCircuits.Gates.U3","text":"U3(qubit::Qubit, θ::Parameter, ϕ::Parameter, λ::Parameter)\n\nUniversal single-qubit rotation gate with three Euler angles, theta, phi and lambda. Matrix Representation\n\nnewcommandthfractheta2\nU3(theta phi lambda) =\n    beginpmatrix\n        cos(th)           -e^ilambdasin(th) \n        e^iphisin(th)  e^i(phi+lambda)cos(th)\n    endpmatrix\n\nqc = QCircuit(1)\nqc.u3(0, 1, 2, 3)\n\nYou can also create a gate without adding parameters, in that case, they will be initialized by random values and can be used in Quantum Machine Learning as the loss function parameters.\n\nusing QuantumCircuits\nusing QuantumCircuits.QML\nusing QuantumCircuits.Execute\n\n# Expected circuit\nexpqc = QCircuit(1)\nexpqc.x(0)\nexpmat = tomatrix(expqc)\n\n# The ansact\nqc = QCircuit(1)\nqc.u3(0)\n\n# Find the parameters which fit the expected unitary matrix in the best way.\nfindparam(expmat, qc)\n\n\n\n\n\n\n","category":"type"},{"location":"0_Single-qubit-gates/#Rx","page":"Single-qubit gates s","title":"Rx","text":"","category":"section"},{"location":"0_Single-qubit-gates/","page":"Single-qubit gates s","title":"Single-qubit gates s","text":"Rx","category":"page"},{"location":"0_Single-qubit-gates/#QuantumCircuits.QCircuits.Gates.Rx","page":"Single-qubit gates s","title":"QuantumCircuits.QCircuits.Gates.Rx","text":"Rx(qubit::Qubit, θ::Parameter)\n\nA single-qubit Pauli gate which represents rotation about the X axis. Matrix Representation\n\nnewcommandthfractheta2\nRx(theta) = exp(-i th X) =\n    beginpmatrix\n        costh    -isinth \n        -isinth  costh\n    endpmatrix\n\nqc = QCircuit(1)\nqc.rx(0, π/2)\n\nYou can also create a gate without adding parameter, in that case, it will be initialized by random values and can be used in Quantum Machine Learning as the loss function parameters.\n\nusing QuantumCircuits\nusing QuantumCircuits.QML\nusing QuantumCircuits.Execute\n\n# Expected circuit\nexpqc = QCircuit(1)\nexpqc.x(0)\nexpmat = tomatrix(expqc)\n\n# The ansact\nqc = QCircuit(1)\nqc.rx(0)\n\n# Find the parameters which fit the expected unitary matrix in the best way.\nfindparam(expmat, qc)\n\n\n\n\n\n\n","category":"type"},{"location":"0_Single-qubit-gates/#Ry","page":"Single-qubit gates s","title":"Ry","text":"","category":"section"},{"location":"0_Single-qubit-gates/","page":"Single-qubit gates s","title":"Single-qubit gates s","text":"Ry","category":"page"},{"location":"0_Single-qubit-gates/#QuantumCircuits.QCircuits.Gates.Ry","page":"Single-qubit gates s","title":"QuantumCircuits.QCircuits.Gates.Ry","text":"Ry(qubit::Qubit, θ::Parameter)\n\nA single-qubit Pauli gate which represents rotation about the Y axis. Matrix Representation\n\nnewcommandthfractheta2\nRy(theta) = exp(-i th Y) =\n    beginpmatrix\n        costh  -sinth \n        sinth  costh\n    endpmatrix\n\nqc = QCircuit(1)\nqc.ry(0, π/2)\n\nYou can also create a gate without adding parameter, in that case, it will be initialized by random values and can be used in Quantum Machine Learning as the loss function parameters.\n\nusing QuantumCircuits\nusing QuantumCircuits.QML\nusing QuantumCircuits.Execute\n\n# Expected circuit\nexpqc = QCircuit(1)\nexpqc.y(0)\nexpmat = tomatrix(expqc)\n\n# The ansact\nqc = QCircuit(1)\nqc.ry(0)\n\n# Find the parameters which fit the expected unitary matrix in the best way.\nfindparam(expmat, qc)\n\n\n\n\n\n\n","category":"type"},{"location":"0_Single-qubit-gates/#Rz","page":"Single-qubit gates s","title":"Rz","text":"","category":"section"},{"location":"0_Single-qubit-gates/","page":"Single-qubit gates s","title":"Single-qubit gates s","text":"Rz","category":"page"},{"location":"0_Single-qubit-gates/#QuantumCircuits.QCircuits.Gates.Rz","page":"Single-qubit gates s","title":"QuantumCircuits.QCircuits.Gates.Rz","text":"Rz(qubit::Qubit, θ::Parameter)\n\nA single-qubit Pauli gate which represents rotation about the Z axis.\n\nMatrix Representation\n\nnewcommandthfractheta2\nRz(theta) = exp(-ith Z) =\nbeginpmatrix\n    e^-ith  0 \n    0  e^ith\nendpmatrix\n\njulia qc = QCircuit(1) qc.rz(0, π/2)\n\n\nYou can also create a gate without adding parameter, in that case, it will be initialized by random values and can be used in Quantum Machine Learning as the loss function parameters.\n\njulia using QuantumCircuits using QuantumCircuits.QML using QuantumCircuits.Execute\n\nExpected circuit\n\nexpqc = QCircuit(1) expqc.z(0) expmat = tomatrix(expqc)\n\nThe ansact\n\nqc = QCircuit(1) qc.rz(0)\n\nFind the parameters which fit the expected unitary matrix in the best way.\n\nfindparam(expmat, qc)\n\n```\n\n\n\n\n\n","category":"type"},{"location":"0_Single-qubit-gates/#H","page":"Single-qubit gates s","title":"H","text":"","category":"section"},{"location":"0_Single-qubit-gates/","page":"Single-qubit gates s","title":"Single-qubit gates s","text":"H","category":"page"},{"location":"0_Single-qubit-gates/#QuantumCircuits.QCircuits.Gates.H","page":"Single-qubit gates s","title":"QuantumCircuits.QCircuits.Gates.H","text":"H(qubit::Qubit)\n\nSingle-qubit Hadamard gate, which is a pi rotation about the X+Z axis, thus equivalent to U3(fracpi20pi) Matrix Representation\n\nH = frac1sqrt2\n        beginpmatrix\n            1  1 \n            1  -1\n        endpmatrix\n\n\n\n\n\n","category":"type"},{"location":"0_Single-qubit-gates/#X","page":"Single-qubit gates s","title":"X","text":"","category":"section"},{"location":"0_Single-qubit-gates/","page":"Single-qubit gates s","title":"Single-qubit gates s","text":"X","category":"page"},{"location":"0_Single-qubit-gates/#QuantumCircuits.QCircuits.Gates.X","page":"Single-qubit gates s","title":"QuantumCircuits.QCircuits.Gates.X","text":"X(qubit::Qubit)\n\nSingle-qubit Pauli-X gate (sigma_x), equivalent to U3(pi0pi) Matrix Representation\n\nX = beginpmatrix\n0  1 \n1  0\nendpmatrix\n\nqc = QCircuit(1)\nqc.x(0)\n\n\n\n\n\n","category":"type"},{"location":"0_Single-qubit-gates/#Y","page":"Single-qubit gates s","title":"Y","text":"","category":"section"},{"location":"0_Single-qubit-gates/","page":"Single-qubit gates s","title":"Single-qubit gates s","text":"Y","category":"page"},{"location":"0_Single-qubit-gates/#QuantumCircuits.QCircuits.Gates.Y","page":"Single-qubit gates s","title":"QuantumCircuits.QCircuits.Gates.Y","text":"Y(qubit::Qubit)\n\nSingle-qubit Pauli-Y gate (sigma_y), equivalent to U3(pifracpi2fracpi2) Matrix Representation\n\nY = beginpmatrix\n0  -i \ni  0\nendpmatrix\n\nqc = QCircuit(1)\nqc.y(0)\n\n\n\n\n\n","category":"type"},{"location":"0_Single-qubit-gates/#Z","page":"Single-qubit gates s","title":"Z","text":"","category":"section"},{"location":"0_Single-qubit-gates/","page":"Single-qubit gates s","title":"Single-qubit gates s","text":"Z","category":"page"},{"location":"0_Single-qubit-gates/#QuantumCircuits.QCircuits.Gates.Z","page":"Single-qubit gates s","title":"QuantumCircuits.QCircuits.Gates.Z","text":"Z(qubit::Qubit)\n\nSingle-qubit Pauli-Z gate (sigma_z), equivalent to U3(00pi) Matrix Representation\n\nZ = beginpmatrix\n1  0 \n0  -1\nendpmatrix\n\nqc = QCircuit(1)\nqc.z(0)\n\n\n\n\n\n","category":"type"},{"location":"0_Single-qubit-gates/#S","page":"Single-qubit gates s","title":"S","text":"","category":"section"},{"location":"0_Single-qubit-gates/","page":"Single-qubit gates s","title":"Single-qubit gates s","text":"S","category":"page"},{"location":"0_Single-qubit-gates/#QuantumCircuits.QCircuits.Gates.S","page":"Single-qubit gates s","title":"QuantumCircuits.QCircuits.Gates.S","text":"S(qubit::Qubit)\n\nSingle-qubit S gate, equivalent to U3(00fracpi2). This  gate is also referred to a square-root of Pauli-Z. Matrix Representation\n\nS = beginpmatrix\n1  0 \n0  i\nendpmatrix\n\nqc = QCircuit(1)\nqc.s(0)\n\n\n\n\n\n","category":"type"},{"location":"0_Single-qubit-gates/#Sd","page":"Single-qubit gates s","title":"Sd","text":"","category":"section"},{"location":"0_Single-qubit-gates/","page":"Single-qubit gates s","title":"Single-qubit gates s","text":"Sd","category":"page"},{"location":"0_Single-qubit-gates/#QuantumCircuits.QCircuits.Gates.Sd","page":"Single-qubit gates s","title":"QuantumCircuits.QCircuits.Gates.Sd","text":"Sd(qubit::Qubit) Single-qubit, hermitian conjugate of the S. This is also an alternative square root of  the Z.  Matrix Representation\n\nS^dagger = beginpmatrix\n1  0 \n0  -i\nendpmatrix\n\nqc = QCircuit(1)\nqc.sd(0)\n\n\n\n\n\n","category":"type"},{"location":"0_Single-qubit-gates/#T","page":"Single-qubit gates s","title":"T","text":"","category":"section"},{"location":"0_Single-qubit-gates/","page":"Single-qubit gates s","title":"Single-qubit gates s","text":"T","category":"page"},{"location":"0_Single-qubit-gates/#QuantumCircuits.QCircuits.Gates.T","page":"Single-qubit gates s","title":"QuantumCircuits.QCircuits.Gates.T","text":"T(qubit::Qubit)\n\nSingle-qubit T gate, equivalent to U3(00fracpi4). This  gate is also referred to as a fracpi8 gate or as a fourth-root of Pauli-Z.  Matrix Representation\n\nT = beginpmatrix\n1  0 \n0  e^ipi4\nendpmatrix\n\nqc = QCircuit(1)\nqc.t(0)\n\n\n\n\n\n","category":"type"},{"location":"0_Single-qubit-gates/#Td","page":"Single-qubit gates s","title":"Td","text":"","category":"section"},{"location":"0_Single-qubit-gates/","page":"Single-qubit gates s","title":"Single-qubit gates s","text":"Td","category":"page"},{"location":"0_Single-qubit-gates/#QuantumCircuits.QCircuits.Gates.Td","page":"Single-qubit gates s","title":"QuantumCircuits.QCircuits.Gates.Td","text":"Td(qubit::Qubit)\n\nSingle-qubit, hermitian conjugate of the T. This gate is equivalent to U3(00-fracpi4). This  gate is also referred to as the fourth-root of Pauli-Z.  Matrix Representation\n\nT^dagger = beginpmatrix\n1  0 \n0  e^-ipi4\nendpmatrix\n\nqc = QCircuit(1)\nqc.td(0)\n\n\n\n\n\n","category":"type"},{"location":"0_Single-qubit-gates/#Sx","page":"Single-qubit gates s","title":"Sx","text":"","category":"section"},{"location":"0_Single-qubit-gates/","page":"Single-qubit gates s","title":"Single-qubit gates s","text":"Sx","category":"page"},{"location":"0_Single-qubit-gates/#QuantumCircuits.QCircuits.Gates.Sx","page":"Single-qubit gates s","title":"QuantumCircuits.QCircuits.Gates.Sx","text":"Sx(qubit::Qubit)\n\nSingle-qubit square root of pauli-X. Matrix Representation\n\nsqrtX = frac12 beginpmatrix\n1 + i  1 - i \n1 - i  1 + i\nendpmatrix\n\nqc = QCircuit(1)\nqc.sx(0)\n\n\n\n\n\n","category":"type"},{"location":"0_Single-qubit-gates/#Sxd","page":"Single-qubit gates s","title":"Sxd","text":"","category":"section"},{"location":"0_Single-qubit-gates/","page":"Single-qubit gates s","title":"Single-qubit gates s","text":"Sxd","category":"page"},{"location":"0_Single-qubit-gates/#QuantumCircuits.QCircuits.Gates.Sxd","page":"Single-qubit gates s","title":"QuantumCircuits.QCircuits.Gates.Sxd","text":"Sxd(qubit::Qubit)\n\nSingle-qubit hermitian conjugate of the square root of pauli-X, or the Sx. Matrix Representation\n\nsqrtX^dagger = frac12 beginpmatrix\n1 - i  1 + i \n1 + i  1 - i\nendpmatrix\n\nqc = QCircuit(1)\nqc.sxd(0)\n\n\n\n\n\n","category":"type"},{"location":"QCircuits/Graph/#QuantumCircuits.QCircuits.Graph","page":"Graph","title":"QuantumCircuits.QCircuits.Graph","text":"","category":"section"},{"location":"QCircuits/Graph/","page":"Graph","title":"Graph","text":"Modules = [QuantumCircuits.QCircuits.Graph]","category":"page"},{"location":"QCircuits/Graph/#QuantumCircuits.QCircuits.Graph.StartEndNode","page":"Graph","title":"QuantumCircuits.QCircuits.Graph.StartEndNode","text":"The index of start and end node.\n\n\n\n\n\n","category":"constant"},{"location":"QCircuits/Graph/#QuantumCircuits.QCircuits.Graph.DirectedGraph","page":"Graph","title":"QuantumCircuits.QCircuits.Graph.DirectedGraph","text":"Circuit direct graph structure\n\n\n\n\n\n","category":"type"},{"location":"QCircuits/Graph/#QuantumCircuits.QCircuits.Graph.DirectedGraph-Union{Tuple{Int64}, Tuple{IndexT}} where IndexT<:Integer","page":"Graph","title":"QuantumCircuits.QCircuits.Graph.DirectedGraph","text":"Create new empyt graph\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Graph/#QuantumCircuits.QCircuits.Graph.qubitToLine-Tuple{Any}","page":"Graph","title":"QuantumCircuits.QCircuits.Graph.qubitToLine","text":"Mapping from qubit number to line number.\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Graph/#QuantumCircuits.QCircuits.QBase.add!-Union{Tuple{IndexT}, Tuple{QuantumCircuits.QCircuits.Graph.DirectedGraph{IndexT}, QuantumGate}} where IndexT<:Integer","page":"Graph","title":"QuantumCircuits.QCircuits.QBase.add!","text":"Add gate to circuit\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Gates/#QuantumCircuits.QCircuits.Gates","page":"Gates","title":"QuantumCircuits.QCircuits.Gates","text":"","category":"section"},{"location":"QCircuits/Gates/","page":"Gates","title":"Gates","text":"Modules = [QuantumCircuits.QCircuits.Gates]\nFilter = t -> !(typeof(t) === DataType && t in Set([\n    QuantumCircuits.QCircuits.Gates.U3,\n    QuantumCircuits.QCircuits.Gates.Rx,\n    QuantumCircuits.QCircuits.Gates.Ry,\n    QuantumCircuits.QCircuits.Gates.Rz,\n    QuantumCircuits.QCircuits.Gates.H,\n    QuantumCircuits.QCircuits.Gates.X,\n    QuantumCircuits.QCircuits.Gates.Y,\n    QuantumCircuits.QCircuits.Gates.Z,\n    QuantumCircuits.QCircuits.Gates.S,\n    QuantumCircuits.QCircuits.Gates.Sd,\n    QuantumCircuits.QCircuits.Gates.T,\n    QuantumCircuits.QCircuits.Gates.Td,\n    QuantumCircuits.QCircuits.Gates.Sx,\n    QuantumCircuits.QCircuits.Gates.Sxd,\n    QuantumCircuits.QCircuits.Gates.CX,]))","category":"page"},{"location":"QCircuits/Gates/#QuantumCircuits.QCircuits.Gates.singlequbitsgates","page":"Gates","title":"QuantumCircuits.QCircuits.Gates.singlequbitsgates","text":"The library of single qubit gates\n\n\n\n\n\n","category":"constant"},{"location":"QCircuits/Gates/#QuantumCircuits.QCircuits.Gates.ParamT","page":"Gates","title":"QuantumCircuits.QCircuits.Gates.ParamT","text":"Parameter type\n\n\n\n\n\n","category":"type"},{"location":"QCircuits/Gates/#QuantumCircuits.QCircuits.Gates.RotationGate","page":"Gates","title":"QuantumCircuits.QCircuits.Gates.RotationGate","text":"Rotation gates\n\n\n\n\n\n","category":"type"},{"location":"QCircuits/Gates/#QuantumCircuits.QCircuits.Gates.U","page":"Gates","title":"QuantumCircuits.QCircuits.Gates.U","text":"The universar single qubit unitary gate\n\n\n\n\n\n","category":"type"},{"location":"QCircuits/Gates/#QuantumCircuits.QCircuits.Gates.UniversalGate","page":"Gates","title":"QuantumCircuits.QCircuits.Gates.UniversalGate","text":"Quantum Universal Gate\n\n\n\n\n\n","category":"type"},{"location":"QCircuits/Gates/#Base.:==-Tuple{QuantumGate, QuantumGate}","page":"Gates","title":"Base.:==","text":"Comparator\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Gates/#Base.show-Tuple{IO, QuantumGate}","page":"Gates","title":"Base.show","text":"Show method\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Gates/#QuantumCircuits.QCircuits.Gates.getqubits-Tuple{QuantumGate}","page":"Gates","title":"QuantumCircuits.QCircuits.Gates.getqubits","text":"Return the qubits on which operate the gate\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Gates/#QuantumCircuits.QCircuits.Gates.getqubitsids-Tuple{QuantumGate}","page":"Gates","title":"QuantumCircuits.QCircuits.Gates.getqubitsids","text":"Return the qubits ids on which operate the gate\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Gates/#QuantumCircuits.QCircuits.Gates.toU3-Tuple{QuantumCircuits.QCircuits.Gates.X}","page":"Gates","title":"QuantumCircuits.QCircuits.Gates.toU3","text":"Convert gate to U3 gate\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Gates/#QuantumCircuits.QCircuits.Gates.u3matrix-Tuple{Any, Any, Any}","page":"Gates","title":"QuantumCircuits.QCircuits.Gates.u3matrix","text":"Return the gate matrix\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Gates/#QuantumCircuits.QCircuits.QBase.simplify-Tuple{QuantumGate}","page":"Gates","title":"QuantumCircuits.QCircuits.QBase.simplify","text":"The simplify the gates.\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Gates/#QuantumCircuits.QCircuits.QBase.standardGateError","page":"Gates","title":"QuantumCircuits.QCircuits.QBase.standardGateError","text":"Method return the error of standard gate\n\n\n\n\n\n","category":"function"},{"location":"QCircuits/Gates/#QuantumCircuits.QCircuits.Gates.@rotationGate-Tuple{Any, Any}","page":"Gates","title":"QuantumCircuits.QCircuits.Gates.@rotationGate","text":"Rotation macro\n\n\n\n\n\n","category":"macro"},{"location":"QCircuits/Gates/#QuantumCircuits.QCircuits.Gates.@singleQubitGate-Tuple{Any, Any}","page":"Gates","title":"QuantumCircuits.QCircuits.Gates.@singleQubitGate","text":"Single qubit create macro\n\n\n\n\n\n","category":"macro"},{"location":"QCircuits/QBase/#QuantumCircuits.QCircuits.QBase","page":"QBase","title":"QuantumCircuits.QCircuits.QBase","text":"","category":"section"},{"location":"QCircuits/QBase/","page":"QBase","title":"QBase","text":"Modules = [QuantumCircuits.QCircuits.QBase]","category":"page"},{"location":"QCircuits/QBase/#QuantumCircuits.QCircuits.QBase.QuantumCircuit","page":"QBase","title":"QuantumCircuits.QCircuits.QBase.QuantumCircuit","text":"Quantum Circuit object\n\n\n\n\n\n","category":"type"},{"location":"QCircuits/QBase/#QuantumCircuits.QCircuits.QBase.QuantumDevice","page":"QBase","title":"QuantumCircuits.QCircuits.QBase.QuantumDevice","text":"Quantum davice, it may be simulator or real hardware.\n\n\n\n\n\n","category":"type"},{"location":"QCircuits/QBase/#QuantumCircuits.QCircuits.QBase.QuantumGate","page":"QBase","title":"QuantumCircuits.QCircuits.QBase.QuantumGate","text":"Quantum Gate\n\n\n\n\n\n","category":"type"},{"location":"QCircuits/QBase/#QuantumCircuits.QCircuits.QBase.QuantumObject","page":"QBase","title":"QuantumCircuits.QCircuits.QBase.QuantumObject","text":"Quantum object :)\n\n\n\n\n\n","category":"type"},{"location":"QCircuits/QBase/#QuantumCircuits.QCircuits.QBase.add!-Tuple{QuantumCircuit, QuantumGate}","page":"QBase","title":"QuantumCircuits.QCircuits.QBase.add!","text":"The quantum gates\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/QBase/#QuantumCircuits.QCircuits.QBase.bindparameters!-Tuple{QuantumCircuits.QCircuits.QBase.QuantumObject}","page":"QBase","title":"QuantumCircuits.QCircuits.QBase.bindparameters!","text":"Bind the parameters to the quantum object\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/QBase/#QuantumCircuits.QCircuits.QBase.setparameters!-Tuple{QuantumCircuits.QCircuits.QBase.QuantumObject, Any}","page":"QBase","title":"QuantumCircuits.QCircuits.QBase.setparameters!","text":"Set the parameters to the quantum object\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/QBase/#QuantumCircuits.QCircuits.QBase.simplify-Tuple{QuantumCircuits.QCircuits.QBase.QuantumObject}","page":"QBase","title":"QuantumCircuits.QCircuits.QBase.simplify","text":"Simplify the quantum object\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/QBase/#QuantumCircuits.QCircuits.QBase.standardGateError-Tuple{QuantumCircuits.QCircuits.QBase.QuantumObject}","page":"QBase","title":"QuantumCircuits.QCircuits.QBase.standardGateError","text":"Method return the error of standard gate\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/QBase/#QuantumCircuits.QCircuits.QBase.tomatrix-Tuple{QuantumCircuits.QCircuits.QBase.QuantumObject}","page":"QBase","title":"QuantumCircuits.QCircuits.QBase.tomatrix","text":"Get the matrix version of the quantum object.\n\n\n\n\n\n","category":"method"},{"location":"quickguide/#Quick-Start-Guide","page":"Quick Start guide","title":"Quick Start Guide","text":"","category":"section"},{"location":"quickguide/#Installation","page":"Quick Start guide","title":"Installation","text":"","category":"section"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"QuantumCircuits is in the general registry so you can install it by:","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"julia> import Pkg\njulia> Pkg.add(\"QuantumCircuits\")","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"Note: The library require  Qiskit installed. You can do this running the 'pip install qiskit qiskit.ignis matplotlib' command.","category":"page"},{"location":"quickguide/#Usage","page":"Quick Start guide","title":"Usage","text":"","category":"section"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"using QuantumCircuits\nusing QuantumCircuits.Execute","category":"page"},{"location":"quickguide/#Introduction","page":"Quick Start guide","title":"Introduction","text":"","category":"section"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"We have various types of backends at our disposal, the simulator written in Julia, the Qiskit simulator, or real device available by Qiskit.","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"# We use the simulator written in Julia\nconst backend = QuantumSimulator()\n\n# Let's create an example circuit.\nqc1 = QCircuit(2)\nqc1.x(0)\nqc1.h(1)\nqc1.cx(0, 1)\nqc1","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"      ┌───┐     \nq0_0: ┤ X ├──■──\n      ├───┤┌─┴─┐\nq0_1: ┤ H ├┤ X ├\n      └───┘└───┘\nc0: 2/══════════","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"Now, we can execute it. Because there is no measurement, we measure all qubits.","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"execute(backend, qc1)","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"4-element Vector{Float64}:\n 0.0\n 0.4999999999999999\n 0.0\n 0.5000000000000001","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"We can also add measurement explicitly.","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"qc1.measure(1, 1)\nqc1","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"      ┌───┐        \nq1_0: ┤ X ├──■─────\n      ├───┤┌─┴─┐┌─┐\nq1_1: ┤ H ├┤ X ├┤M├\n      └───┘└───┘└╥┘\nc1: 2/═══════════╩═\n                 1 ","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"execute(backend, qc1)","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"2-element Vector{Float64}:\n 0.4999999999999999\n 0.5000000000000001","category":"page"},{"location":"quickguide/#Registers","page":"Quick Start guide","title":"Registers","text":"","category":"section"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"We can also create circuit with registers directly.","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"qr = QuantumRegister(3)\ncr = ClassicalRegister(2)\nqc = QCircuit(qr, cr)\nqc.h(0)\nqc.x(1)\nqc.x(2)\nqc.measure([0, 1], [0, 1])\nqc","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"      ┌───┐┌─┐   \nq2_0: ┤ H ├┤M├───\n      ├───┤└╥┘┌─┐\nq2_1: ┤ X ├─╫─┤M├\n      ├───┤ ║ └╥┘\nq2_2: ┤ X ├─╫──╫─\n      └───┘ ║  ║ \nc2: 2/══════╩══╩═\n            0  1 ","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"execute(backend, qc)","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"4-element Vector{Float64}:\n 0.0\n 0.0\n 0.5000000000000001\n 0.4999999999999999","category":"page"},{"location":"quickguide/#Bug-reports-and-Contributing","page":"Quick Start guide","title":"Bug reports and Contributing","text":"","category":"section"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"Please report any issues via the Github issue tracker. All types of issues are welcome and encouraged; this includes bug reports, documentation typos, feature requests, etc. ","category":"page"},{"location":"quickguide/","page":"Quick Start guide","title":"Quick Start guide","text":"QuantumCircuits is being actively developed and suggestions or other forms of contributions are encouraged. ","category":"page"},{"location":"Execute/#Execute","page":"Execute","title":"Execute","text":"","category":"section"},{"location":"Execute/","page":"Execute","title":"Execute","text":"Modules = [QuantumCircuits.Execute]","category":"page"},{"location":"Execute/#QuantumCircuits.Execute.QiskitQuantum","page":"Execute","title":"QuantumCircuits.Execute.QiskitQuantum","text":"Qiskit Quantum Device\n\n\n\n\n\n","category":"type"},{"location":"Execute/#QuantumCircuits.Execute.QuantumSimulator","page":"Execute","title":"QuantumCircuits.Execute.QuantumSimulator","text":"Quantum Simulator\n\n\n\n\n\n","category":"type"},{"location":"Execute/#QuantumCircuits.Execute.execute","page":"Execute","title":"QuantumCircuits.Execute.execute","text":"Function execute the quantum circuit on simulator\n\n\n\n\n\n","category":"function"},{"location":"Execute/#QuantumCircuits.Execute.getShift-Tuple{Any, Any}","page":"Execute","title":"QuantumCircuits.Execute.getShift","text":"Function return the shift\n\n\n\n\n\n","category":"method"},{"location":"Execute/#QuantumCircuits.Execute.loss_expected_zero_state-Tuple{Any}","page":"Execute","title":"QuantumCircuits.Execute.loss_expected_zero_state","text":"Loss method to check if final state is zero.\n\n\n\n\n\n","category":"method"},{"location":"Execute/#QuantumCircuits.Execute.qderivative","page":"Execute","title":"QuantumCircuits.Execute.qderivative","text":"Caclulate loss value and it derivateive\n\n\n\n\n\n","category":"function"},{"location":"Execute/#QuantumCircuits.Execute.qexecute","page":"Execute","title":"QuantumCircuits.Execute.qexecute","text":"Caclulate the the value.\n\n\n\n\n\n","category":"function"},{"location":"Execute/#QuantumCircuits.Execute.qjacobian","page":"Execute","title":"QuantumCircuits.Execute.qjacobian","text":"Caclulate the jacobian on device.\n\n\n\n\n\n","category":"function"},{"location":"Execute/#QuantumCircuits.Execute.setAndConvert-Tuple{Any, Vector{<:Number}}","page":"Execute","title":"QuantumCircuits.Execute.setAndConvert","text":"Set the parameters to the cicquit and convert to qiskit\n\n\n\n\n\n","category":"method"},{"location":"Execute/#QuantumCircuits.Execute.state2probability-Tuple{Any}","page":"Execute","title":"QuantumCircuits.Execute.state2probability","text":"Method convert state to probability\n\n\n\n\n\n","category":"method"},{"location":"Execute/#QuantumCircuits.Execute.@bra_str-Tuple{Any}","page":"Execute","title":"QuantumCircuits.Execute.@bra_str","text":"Macro proces ket binary vector to quantum state\n\n\n\n\n\n","category":"macro"},{"location":"Execute/#QuantumCircuits.Execute.@ket_str-Tuple{Any}","page":"Execute","title":"QuantumCircuits.Execute.@ket_str","text":"Macro proces ket binary vector to quantum state\n\n\n\n\n\n","category":"macro"},{"location":"QML/Optimization/#QuantumCircuits.QML.Optimization","page":"Optimization","title":"QuantumCircuits.QML.Optimization","text":"","category":"section"},{"location":"QML/Optimization/#Eva","page":"Optimization","title":"Eva","text":"","category":"section"},{"location":"QML/Optimization/","page":"Optimization","title":"Optimization","text":"QuantumCircuits.QML.Optimization.Eva","category":"page"},{"location":"QML/Optimization/#QuantumCircuits.QML.Optimization.Eva","page":"Optimization","title":"QuantumCircuits.QML.Optimization.Eva","text":"Evolutionary Alpha optimization algorithm\n\nThe most popular optimization method in machine learning are is ADAM: \"Adam: A Method for Stochastic Optimization\" https://arxiv.org/abs/1412.6980. This method use only first derivative and the step is different for all of the parameters and it is changed in the way that combine the RMSprop and momentum method. I've found that better for your case work method which has different adaptive approach we calculate the estimation of the second derivative using the changes of derivative from two steps.\n\n\n\n\n\n","category":"type"},{"location":"QML/Optimization/#Methods","page":"Optimization","title":"Methods","text":"","category":"section"},{"location":"QML/Optimization/","page":"Optimization","title":"Optimization","text":"Modules = [QuantumCircuits.QML.Optimization]\nFilter = t -> !(t in Set([QuantumCircuits.QML.Optimization.Eva]))","category":"page"},{"location":"QML/Optimization/#QuantumCircuits.QML.Optimization.Adam","page":"Optimization","title":"QuantumCircuits.QML.Optimization.Adam","text":"Adam optimization algoritm\n\n\n\n\n\n","category":"type"},{"location":"QML/Optimization/#QuantumCircuits.QML.Optimization.Momentum","page":"Optimization","title":"QuantumCircuits.QML.Optimization.Momentum","text":"Momentum optimization algoritm\n\n\n\n\n\n","category":"type"},{"location":"QML/Optimization/#QuantumCircuits.QML.Optimization.RMSprop","page":"Optimization","title":"QuantumCircuits.QML.Optimization.RMSprop","text":"RMSprop optimization algoritm\n\n\n\n\n\n","category":"type"},{"location":"QML/Optimization/#QuantumCircuits.QML.Optimization.StandardGD","page":"Optimization","title":"QuantumCircuits.QML.Optimization.StandardGD","text":"Standard gradient descent\n\n\n\n\n\n","category":"type"},{"location":"QCircuits/Circuit/#QuantumCircuits.QCircuits.Circuit","page":"Circuit","title":"QuantumCircuits.QCircuits.Circuit","text":"","category":"section"},{"location":"QCircuits/Circuit/#Quantum-Circuit","page":"Circuit","title":"Quantum Circuit","text":"","category":"section"},{"location":"QCircuits/Circuit/","page":"Circuit","title":"Circuit","text":"QuantumCircuits.QCircuits.Circuit.QCircuit","category":"page"},{"location":"QCircuits/Circuit/#QuantumCircuits.QCircuits.Circuit.QCircuit","page":"Circuit","title":"QuantumCircuits.QCircuits.Circuit.QCircuit","text":"QCircuit - Quantum Circuit structure\n\nThe fundamental element of quantum computing is the quantum circuit. A quantum circuit is a computational routine consisting of coherent quantum operations on quantum data, such as qubits. It is an ordered sequence of quantum gates, measurements and resets, which may be conditioned on real-time classical computation. A set of quantum gates is said to be universal if any unitary transformation of the quantum data can be efficiently approximated arbitrarily well as as sequence of gates in the set. Any quantum program can be represented by a sequence of quantum circuits and classical near-time computation.\n\nIn QuantumCircuits, this core element is represented by the QCircuit struct. Below is an example of a quantum circuit that makes a three-qubit GHZ state defined as:\n\npsirangle = frac000rangle + 111ranglesqrt2\n\nusing QuantumCircuits\nqc = QCircuit(3)\nqc.h(0)\nqc.cx(0, 1)\nqc.cx(1, 2)\n\n      ┌───┐          \nq0_0: ┤ H ├──■───────\n      └───┘┌─┴─┐     \nq0_1: ─────┤ X ├──■──\n           └───┘┌─┴─┐\nq0_2: ──────────┤ X ├\n                └───┘\nc0: 3/═══════════════\n                     \n\n\n\n\n\n","category":"type"},{"location":"QCircuits/Circuit/#Methods","page":"Circuit","title":"Methods","text":"","category":"section"},{"location":"QCircuits/Circuit/","page":"Circuit","title":"Circuit","text":"Modules = [QuantumCircuits.QCircuits.Circuit]\nFilter = t -> !(typeof(t) === DataType && t in Set([\n    QuantumCircuits.QCircuits.Circuit.QCircuit]))","category":"page"},{"location":"QCircuits/Circuit/#Base.show-Tuple{IO, QCircuit}","page":"Circuit","title":"Base.show","text":"Show method\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Circuit/#QuantumCircuits.QCircuits.Circuit.getRandParameters-Tuple{QCircuit}","page":"Circuit","title":"QuantumCircuits.QCircuits.Circuit.getRandParameters","text":"Function create new random parameters vector\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Circuit/#QuantumCircuits.QCircuits.Circuit.getparameters-Tuple{QCircuit}","page":"Circuit","title":"QuantumCircuits.QCircuits.Circuit.getparameters","text":"Function create new parameters vector\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Circuit/#QuantumCircuits.QCircuits.Circuit.nop","page":"Circuit","title":"QuantumCircuits.QCircuits.Circuit.nop","text":"Nothing function\n\n\n\n\n\n","category":"function"},{"location":"QCircuits/Circuit/#QuantumCircuits.QCircuits.Circuit.setClassicalRegister!-Tuple{QCircuit, ClassicalRegister}","page":"Circuit","title":"QuantumCircuits.QCircuits.Circuit.setClassicalRegister!","text":"Add the classical register to circuit.\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Circuit/#QuantumCircuits.QCircuits.Circuit.toQiskit-Tuple{QCircuit}","page":"Circuit","title":"QuantumCircuits.QCircuits.Circuit.toQiskit","text":"Function to convert QCircuit to Qiskit circuit\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Circuit/#QuantumCircuits.QCircuits.QBase.add!-Tuple{QCircuit, QuantumGate}","page":"Circuit","title":"QuantumCircuits.QCircuits.QBase.add!","text":"Add gate to circuit\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Circuit/#QuantumCircuits.QCircuits.QBase.bindparameters!-Tuple{QCircuit}","page":"Circuit","title":"QuantumCircuits.QCircuits.QBase.bindparameters!","text":"Function bind the parameters, so now there only values.\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Circuit/#QuantumCircuits.QCircuits.QBase.measure!","page":"Circuit","title":"QuantumCircuits.QCircuits.QBase.measure!","text":"Add measures to circuit\n\n\n\n\n\n","category":"function"},{"location":"QCircuits/Circuit/#QuantumCircuits.QCircuits.QBase.measure!-2","page":"Circuit","title":"QuantumCircuits.QCircuits.QBase.measure!","text":"Add measures to circuit\n\n\n\n\n\n","category":"function"},{"location":"QCircuits/Circuit/#QuantumCircuits.QCircuits.QBase.setparameters!-Tuple{QCircuit, Any}","page":"Circuit","title":"QuantumCircuits.QCircuits.QBase.setparameters!","text":"Save the parameters to the quantum circuits.\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Circuit/#QuantumCircuits.QCircuits.Circuit.@addfunction-Tuple{Any, Any}","page":"Circuit","title":"QuantumCircuits.QCircuits.Circuit.@addfunction","text":"Add function macro\n\n\n\n\n\n","category":"macro"},{"location":"Simulation/problem_definition/","page":"Problem definition","title":"Problem definition","text":"This solution was created during participation in IBM Quantum’s Open Science Prize 2021. The description of the problem definition uses the materials created for these professions and are available in GitHub.","category":"page"},{"location":"Simulation/problem_definition/","page":"Problem definition","title":"Problem definition","text":"The whole solution using QuantumCircuits library is available in GitHub.","category":"page"},{"location":"Simulation/problem_definition/#Introduction","page":"Problem definition","title":"1 Introduction","text":"","category":"section"},{"location":"Simulation/problem_definition/","page":"Problem definition","title":"Problem definition","text":"We would like to implement a single trotter step of 𝑋𝑋𝑋 Heisenberg Spin Model uses as less gates as this is possible to reduce the noises and errors real quantum device. The 𝑋𝑋𝑋 Heisenberg Hamiltonian H_textHeis as defined below:","category":"page"},{"location":"Simulation/problem_definition/","page":"Problem definition","title":"Problem definition","text":"beginequation\nH_textHeis = sum_langle ij rangle^N J left(sigma_x^(i)sigma_x^(j) + sigma_y^(i)sigma_y^(j) + sigma_z^(i)sigma_z^(j)right)\nendequation","category":"page"},{"location":"Simulation/problem_definition/","page":"Problem definition","title":"Problem definition","text":"N","category":"page"},{"location":"Simulation/problem_definition/","page":"Problem definition","title":"Problem definition","text":"is the number of spin-1/2 particles in model. The operators sigma_x, sigma_y, and sigma_z are Pauli operators where the i and j superscripts label which qubit they act on. For example, sigma_x^(1) would be the sigma_x operator acting on only qubit 1 (which is the 2nd qubit since indexing starts at 0). This version of the general Heisenberg spin model is called XXX because the same J value multiplies each pair of Pauli operators. The sum notation langle ij rangle means the sum is over nearest neighbors (only qubits next to each other interact), and J is the interaction strength, which we will set J=1.","category":"page"},{"location":"Simulation/problem_definition/","page":"Problem definition","title":"Problem definition","text":"In our example we use the quantum system of 3 spin-1/2 particles.","category":"page"},{"location":"Simulation/problem_definition/","page":"Problem definition","title":"Problem definition","text":"H_textHeis3 = sigma_x^(0)sigma_x^(1) + sigma_x^(1)sigma_x^(2) + sigma_y^(0)sigma_y^(1) + sigma_y^(1)sigma_y^(2) + sigma_z^(0)sigma_z^(1) + sigma_z^(1)sigma_z^(2)","category":"page"},{"location":"Simulation/problem_definition/#3-Time-Evolution","page":"Problem definition","title":"1-3 Time Evolution","text":"","category":"section"},{"location":"Simulation/problem_definition/","page":"Problem definition","title":"Problem definition","text":"Knowing the Hamiltonian, we can determine how quantum states of that system evolve in time by solving the Schrödinger equation","category":"page"},{"location":"Simulation/problem_definition/","page":"Problem definition","title":"Problem definition","text":"ihbar dfracddtpsi(t)rangle = H psi(t)rangle","category":"page"},{"location":"Simulation/problem_definition/","page":"Problem definition","title":"Problem definition","text":"For simplicity, let's set hbar = 1. We know that the Hamiltonian H_textheis3 does not change in time, so the solution to the Schrödinger equation is an exponential of the Hamiltonian operator","category":"page"},{"location":"Simulation/problem_definition/","page":"Problem definition","title":"Problem definition","text":"beginalign\nU_textHeis3(t) = e^-it H_textHeis3 = expleft(-it H_textHeis3right) \nU_textHeis3(t) = expleft-it sum_langle ij rangle^N=3 left(sigma_x^(i)sigma_x^(j) + sigma_y^(i)sigma_y^(j) + sigma_z^(i)sigma_z^(j)right) right \nU_textHeis3(t) = expleft-it left(sigma_x^(0)sigma_x^(1) + sigma_x^(1)sigma_x^(2) + sigma_y^(0)sigma_y^(1) + sigma_y^(1)sigma_y^(2) + sigma_z^(0)sigma_z^(1) + sigma_z^(1)sigma_z^(2)right) right\nendalign","category":"page"},{"location":"Simulation/problem_definition/","page":"Problem definition","title":"Problem definition","text":"Now that we have the time evolution operator U_textHeis3(t), we can simulate changes in a state of the system (psi(t)rangle) over time psi(t)rangle = U_textHeis3(t)psi(t=0)rangle. ","category":"page"},{"location":"Simulation/problem_definition/#5-Decomposition-of-U_{\\text{Heis3}}(t)-Into-Quantum-Gates","page":"Problem definition","title":"1-5 Decomposition of U_textHeis3(t) Into Quantum Gates","text":"","category":"section"},{"location":"Simulation/problem_definition/","page":"Problem definition","title":"Problem definition","text":"To execute U_textHeis3(t) on a circuit model Quantum Circuit quantum computer, we must decompose U_textHeis3(t) into a product of single and two-qubit gates that are native to that quantum computer. There are a variety of techniques to do this. For this Open Science Prize, you will only use Trotterization (which is sometimes refered to as Suzuki-Trotterization decomposition, Trotter formulas, product formulas, and other names).","category":"page"},{"location":"Simulation/problem_definition/","page":"Problem definition","title":"Problem definition","text":"Below, we show an example Trotterization as outlined in [1-2].","category":"page"},{"location":"Simulation/problem_definition/","page":"Problem definition","title":"Problem definition","text":"Since the Pauli operators do not commute with each other, the exponential U_textHeis3(t) cannot be split into a product of simpler exponentials. However, we can approximate U_textHeis3(t) as a product of simpler exponentials through Trotterization. Consider a subsystem of 2 spin-1/2 particles within the larger 3 spin system. The Hamiltonian on spins i and j (ij in 012) would be H^(ij)_textHeis2 = sigma_x^(i)sigma_x^(j) + sigma_y^(i)sigma_y^(j) + sigma_z^(i)sigma_z^(j). Rewritting U_textHeis3(t) in terms of the two possible subsystems within the total N=3 system you will simulate,","category":"page"},{"location":"Simulation/problem_definition/","page":"Problem definition","title":"Problem definition","text":"U_textHeis3(t) = expleft-i t left(H^(01)_textHeis2 + H^(12)_textHeis2 right)right","category":"page"},{"location":"Simulation/problem_definition/","page":"Problem definition","title":"Problem definition","text":"H^(01)_textHeis2","category":"page"},{"location":"Simulation/problem_definition/","page":"Problem definition","title":"Problem definition","text":"and H^(12)_textHeis2 do not commute, so U_textHeis3(t) neq expleft(-i t H^(01)_textHeis2right) expleft(-i t H^(12)_textHeis2 right). But, this product decomposition can be approximated with Trotterization which says U_textHeis3(t) is approximately a short evolution of H^(01)_textHeis2 (time = tn) and followed by a short evolution of H^(12)_textHeis2 (time = tn) repeated n times","category":"page"},{"location":"Simulation/problem_definition/","page":"Problem definition","title":"Problem definition","text":"beginalign\nU_textHeis3(t) = expleft-i t left(H^(01)_textHeis2 + H^(12)_textHeis2 right)right \nU_textHeis3(t) approx leftexpleft(dfrac-itnH^(01)_textHeis2right) expleft(dfrac-itnH^(12)_textHeis2 right)right^n\nendalign","category":"page"},{"location":"Simulation/problem_definition/","page":"Problem definition","title":"Problem definition","text":"n is the number of Trotter steps, and as n increases, the approximation becomes more accurate. (Note that how a untiary is split up into subsystems for Trotterization is not necessarily unique.) The decomposition goes further. Within each 2 spin subsystems, the Pauli operator pairs (sigma_x^(i)sigma_x^(j), sigma_y^(i)sigma_y^(j), and sigma_z^(i)sigma_z^(j)) commute. This means we can decompose the exponential of a subsystem Hamiltonian (H^(ij)_textHeis2) into a product of even simpler exponentials getting us closer to a gate implementation of U_textHeis3(t)","category":"page"},{"location":"Simulation/problem_definition/","page":"Problem definition","title":"Problem definition","text":"beginalign\nU_textHeis3(t) approx leftexpleft(dfrac-itnH^(01)_textHeis2right) expleft(dfrac-itnH^(12)_textHeis2 right)right^n \nU_textHeis3(t) approx leftexpleft(dfrac-itnleft(sigma_x^(0)sigma_x^(1) + sigma_y^(0)sigma_y^(1) + sigma_z^(0)sigma_z^(1)right)right) expleft(dfrac-itnleft(sigma_x^(1)sigma_x^(2) + sigma_y^(1)sigma_y^(2) + sigma_z^(1)sigma_z^(2)right)right)right^n \nU_textHeis3(t) approx leftexpleft(dfrac-itnsigma_x^(0)sigma_x^(1)right) expleft(dfrac-itnsigma_y^(0)sigma_y^(1)right) expleft(dfrac-itnsigma_z^(0)sigma_z^(1)right) expleft(dfrac-itnsigma_x^(1)sigma_x^(2)right) expleft(dfrac-itnsigma_y^(1)sigma_y^(2)right) expleft(dfrac-itnsigma_z^(1)sigma_z^(2)right)right^n\nendalign","category":"page"},{"location":"Simulation/problem_definition/","page":"Problem definition","title":"Problem definition","text":"For simplicity, and to use more common notation, let's rename the products with XX(2t) = expleft(-it sigma_xsigma_xright), YY(2t) = expleft(-it sigma_ysigma_yright), and ZZ(2t) = expleft(-it sigma_zsigma_zright) and rewrite the Trotterized U_textHeis3(t)","category":"page"},{"location":"Simulation/problem_definition/","page":"Problem definition","title":"Problem definition","text":"U_textHeis3(t) approx leftXXleft(frac2tnright)^(01) YYleft(frac2tnright)^(01) ZZleft(frac2tnright)^(01) XXleft(frac2tnright)^(12) YYleft(frac2tnright)^(12) ZZleft(frac2tnright)^(12) right^n","category":"page"},{"location":"Simulation/problem_definition/","page":"Problem definition","title":"Problem definition","text":"And that's it! We have now approximately decomposed U_textHeis3(t) into two-qubit gates XX(t), YY(t), and ZZ(t). These gates are not native to superconducting qubits, but in Section 2, they will be further decomposed into native single and two-qubit gates with further details found in the supplementary material.","category":"page"},{"location":"Simulation/problem_definition/","page":"Problem definition","title":"Problem definition","text":"[1] Y. Salathe, et al., Digital Quantum Simulation of Spin Models with Circuit Quantum Electrodynamics, Phys. Rev. X 5, 021027 (2015)","category":"page"},{"location":"Simulation/problem_definition/","page":"Problem definition","title":"Problem definition","text":"[2] F. Tacchino, et al., Quantum Computers as Universal Quantum Simulators: State-of-the-Art and Perspectives, Adv. Quantum Technol. 3 3 (2020) [free arxiv version]","category":"page"},{"location":"QCircuits/ComplexGates/#QuantumCircuits.QCircuits.ComplexGates","page":"ComplexGates","title":"QuantumCircuits.QCircuits.ComplexGates","text":"","category":"section"},{"location":"QCircuits/ComplexGates/","page":"ComplexGates","title":"ComplexGates","text":"Modules = [QuantumCircuits.QCircuits.ComplexGates]","category":"page"},{"location":"QCircuits/ComplexGates/#QuantumCircuits.QCircuits.ComplexGates.U4","page":"ComplexGates","title":"QuantumCircuits.QCircuits.ComplexGates.U4","text":"Universary two qubits gate.\n\n\n\n\n\n","category":"type"},{"location":"QCircuits/ComplexGates/#QuantumCircuits.QCircuits.Gates.getqubits-Tuple{QuantumCircuits.QCircuits.ComplexGates.U4}","page":"ComplexGates","title":"QuantumCircuits.QCircuits.Gates.getqubits","text":"Return the qubits on which operate the gate\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/ComplexGates/#QuantumCircuits.QCircuits.Gates.getqubitsids-Tuple{QuantumCircuits.QCircuits.ComplexGates.U4}","page":"ComplexGates","title":"QuantumCircuits.QCircuits.Gates.getqubitsids","text":"Return the qubits ids on which operate the gate\n\n\n\n\n\n","category":"method"},{"location":"#QuantumCircuits.jl","page":"Introduction","title":"QuantumCircuits.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"QuantumCircuits is an open-source library for working with quantum computers at the application level, especially for Quantum Machine Learning and Quantum Finance.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Library QuantumCircuits contains the following modules:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"QCircuits - the module used to create quantum circuits, manipulate them and convert them to Qiskit if necessary.\nExecute - module to execute the quantum circuit on a Julia quantum simulator or on a real device using Qiskit.\nQML - Quantum Machine learning module which contains the optimization method and QML tools.\nSimulation - Quantum Simulation module","category":"page"},{"location":"QCircuits/Math/#QuantumCircuits.QCircuits.Math","page":"Math","title":"QuantumCircuits.QCircuits.Math","text":"","category":"section"},{"location":"QCircuits/Math/","page":"Math","title":"Math","text":"Modules = [QuantumCircuits.QCircuits.Math]","category":"page"},{"location":"QCircuits/Math/#QuantumCircuits.QCircuits.Math.eye-Tuple{Any}","page":"Math","title":"QuantumCircuits.QCircuits.Math.eye","text":"Return the identity matrix.\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Math/#QuantumCircuits.QCircuits.Math.matrix_norm-Tuple{Any}","page":"Math","title":"QuantumCircuits.QCircuits.Math.matrix_norm","text":"Calculate the matrix norm\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Math/#QuantumCircuits.QCircuits.Math.min_observe_unitary_error-Tuple{Any, Any}","page":"Math","title":"QuantumCircuits.QCircuits.Math.min_observe_unitary_error","text":"Calculate the minimum observe unitary matrix error.\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Math/#QuantumCircuits.QCircuits.Math.observe_unitary_error","page":"Math","title":"QuantumCircuits.QCircuits.Math.observe_unitary_error","text":"Calculate the observe unitary matrix error, the error which we can obserwe from quantum state\n\n\n\n\n\n","category":"function"},{"location":"QCircuits/Math/#QuantumCircuits.QCircuits.Math.unitary_error-Tuple{Any, Any}","page":"Math","title":"QuantumCircuits.QCircuits.Math.unitary_error","text":"Calculate the unitary matrix error\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Registers/#QuantumCircuits.QCircuits.Registers","page":"Registers","title":"QuantumCircuits.QCircuits.Registers","text":"","category":"section"},{"location":"QCircuits/Registers/","page":"Registers","title":"Registers","text":"Modules = [QuantumCircuits.QCircuits.Registers]","category":"page"},{"location":"QCircuits/Registers/#QuantumCircuits.QCircuits.Registers.Bit","page":"Registers","title":"QuantumCircuits.QCircuits.Registers.Bit","text":"The abstract bit\n\n\n\n\n\n","category":"type"},{"location":"QCircuits/Registers/#QuantumCircuits.QCircuits.Registers.Cbit","page":"Registers","title":"QuantumCircuits.QCircuits.Registers.Cbit","text":"Classical bit\n\n\n\n\n\n","category":"type"},{"location":"QCircuits/Registers/#QuantumCircuits.QCircuits.Registers.Qubit","page":"Registers","title":"QuantumCircuits.QCircuits.Registers.Qubit","text":"Quantum bit\n\n\n\n\n\n","category":"type"},{"location":"QCircuits/Registers/#QuantumCircuits.QCircuits.Registers.Register","page":"Registers","title":"QuantumCircuits.QCircuits.Registers.Register","text":"The abstract register\n\n\n\n\n\n","category":"type"},{"location":"QCircuits/Registers/#Base.eachindex-Tuple{QuantumCircuits.QCircuits.Registers.Register}","page":"Registers","title":"Base.eachindex","text":"Each index method\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Registers/#Base.getindex-Tuple{QuantumCircuits.QCircuits.Registers.Register, Integer}","page":"Registers","title":"Base.getindex","text":"Get bit from register on given index.\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Registers/#Base.iterate-Tuple{QuantumCircuits.QCircuits.Registers.Register}","page":"Registers","title":"Base.iterate","text":"Iterable method\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Registers/#Base.length-Tuple{QuantumCircuits.QCircuits.Registers.Register}","page":"Registers","title":"Base.length","text":"The size of register.\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Registers/#Base.size-Tuple{QuantumCircuits.QCircuits.Registers.Register}","page":"Registers","title":"Base.size","text":"Size\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Registers/#QuantumCircuits.QCircuits.Registers.getid-Tuple{QuantumCircuits.QCircuits.Registers.Bit}","page":"Registers","title":"QuantumCircuits.QCircuits.Registers.getid","text":"Get bit index\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Registers/#QuantumCircuits.QCircuits.Registers.setid-Tuple{QuantumCircuits.QCircuits.Registers.Bit, Integer}","page":"Registers","title":"QuantumCircuits.QCircuits.Registers.setid","text":"Get bit index\n\n\n\n\n\n","category":"method"},{"location":"QCircuits/Registers/#QuantumCircuits.QCircuits.Registers.@register-Tuple{Any, Any}","page":"Registers","title":"QuantumCircuits.QCircuits.Registers.@register","text":"Register macro\n\n\n\n\n\n","category":"macro"}]
}
