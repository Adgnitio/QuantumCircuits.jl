<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Algorithm description · QuantumCircuits.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../quickguide/">Quick Start guide</a></li><li><span class="tocitem">Quantum Gates Library</span><ul><li><a class="tocitem" href="../../0_Single-qubit-gates/">Single-qubit gates s</a></li><li><a class="tocitem" href="../../1_Two-qubit-gates/">Two-qubit gates</a></li></ul></li><li><span class="tocitem">Novel algorithm to Simulation on NISQ device</span><ul><li><a class="tocitem" href="../problem_definition/">Problem definition</a></li><li><a class="tocitem" href="../U4_Cartan_decomposition/">U4 - Cartan&#39;s KAK decomposition</a></li><li class="is-active"><a class="tocitem" href>Algorithm description</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Introduction"><span>2 Introduction</span></a></li><li class="toplevel"><a class="tocitem" href="#The-overview-of-algorithm"><span>3 The overview of algorithm</span></a></li><li><a class="tocitem" href="#.1-Next-step"><span>3.1 Next step</span></a></li><li><a class="tocitem" href="#.2-Result-evaluation"><span>3.2 Result evaluation</span></a></li><li><a class="tocitem" href="#.3-Trening"><span>3.3 Trening</span></a></li><li class="toplevel"><a class="tocitem" href="#Execute-on-the-real-device"><span>4 Execute on the real device</span></a></li></ul></li></ul></li><li><span class="tocitem">Library References</span><ul><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox"/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">QCircuits</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../QCircuits/Circuit/">Circuit</a></li><li><a class="tocitem" href="../../QCircuits/Gates/">Gates</a></li><li><a class="tocitem" href="../../QCircuits/Qiskit/">Qiskit</a></li><li><a class="tocitem" href="../../QCircuits/Registers/">Registers</a></li><li><a class="tocitem" href="../../QCircuits/Graph/">Graph</a></li><li><a class="tocitem" href="../../QCircuits/OtherGates/">OtherGates</a></li><li><a class="tocitem" href="../../QCircuits/ComplexGates/">ComplexGates</a></li><li><a class="tocitem" href="../../QCircuits/Instructions/">Instructions</a></li><li><a class="tocitem" href="../../QCircuits/Math/">Math</a></li><li><a class="tocitem" href="../../QCircuits/QBase/">QBase</a></li></ul></li><li><a class="tocitem" href="../../Execute/">Execute</a></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">QML</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../QML/QML/">QML</a></li><li><a class="tocitem" href="../../QML/Optimization/">Optimization</a></li><li><a class="tocitem" href="../../QML/CircuitOptimization/">Gates</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Novel algorithm to Simulation on NISQ device</a></li><li class="is-active"><a href>Algorithm description</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Algorithm description</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Adgnitio/QuantumCircuits.jl/blob/master/docs/src/Simulation/Trotterization.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Novel-algorithm-to-Simulation-on-NISQ-device"><a class="docs-heading-anchor" href="#Novel-algorithm-to-Simulation-on-NISQ-device">1 Novel algorithm to Simulation on NISQ device</a><a id="Novel-algorithm-to-Simulation-on-NISQ-device-1"></a><a class="docs-heading-anchor-permalink" href="#Novel-algorithm-to-Simulation-on-NISQ-device" title="Permalink"></a></h1><pre><code class="language-julia hljs">using QuantumCircuits
using QuantumCircuits.QML
using QuantumCircuits.QCircuits.Qiskit
using QuantumCircuits.QCircuits.Qiskit: qiskit
using QuantumCircuits.QCircuits.Circuit
using QuantumCircuits.QCircuits.Circuit: toQiskit, getCode
using QuantumCircuits.QCircuits.Gates: CX
using QuantumCircuits.Execute: generate_mesuere_circuits, extractProbability, correctMeasures</code></pre><h1 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">2 Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h1><p>Our goal is to implement the Trotterization to evolve the specified state <span>$|110\rangle$</span>, under the specified Hamiltonian, for the specified duration <span>$\pi$</span> but utilize as many Trotter steps as is possible. The algorithm, in principle, should be executed for any state, Hamiltonian, and duration.</p><p>Unfortunately on the current quantum computer, this is impossible regarding the noises. Therefore I&#39;ve proposed an algorithm that can break the Trotterization into pieces with a shorter depth which can be executed on current quantum computers. The main points and requirements of the algorithm:</p><ul><li>It breaks the Trotterization into pieces with a shorter depth.</li><li>It is convergent to the final state.</li><li>The designed algorithm should allow us to find the simulated state for an arbitrary number of qubits.</li></ul><p>The first stage is to find a way how to effectively implement a trotter step, the details of that can be found in  <a href="../U4_Cartan_decomposition/#Cartan&#39;s-KAK-decomposition">Cartan&#39;s KAK decomposition</a>. </p><h1 id="The-overview-of-algorithm"><a class="docs-heading-anchor" href="#The-overview-of-algorithm">3 The overview of algorithm</a><a id="The-overview-of-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#The-overview-of-algorithm" title="Permalink"></a></h1><p>Let&#39;s assume, that we would like to implement an algorithm with 10 Trotter steps, but using at most 2 Trotter steps in single circuit execution. We can do this by implementing the circuit below and using the gradient descent method to find the parameters <span>$\theta_1$</span> that minimize our cost function. The cost function is chosen that after finding the optimal parameters the output status is <span>$|0\rangle_3$</span>. Why I use <span>$|000\rangle$</span> as a target state, there are a few reasons:</p><ol><li>We need to avoid any superposition and use only base state <span>$|000\rangle$</span>, <span>$|001\rangle$</span>, eg. Using superposition implies variance &gt; 0 during expectation measurement even on the perfect device, for the base state the variance is equal to 0. This is important because any fluctuation impact derivative calculation using the shift-parameter rule.</li><li>The <span>$|000\rangle$</span> state in natural choice because this is the starting point for quantum device.</li></ol><p>First, we would like to fit the expected distribution. The use of entropy loos is a natural choice point. In our case, the expected distribution has only one non zero value for state 000, so the entropy loss looks like: <span>$-\ln{P(|000\rangle)}$</span> But the other requirement is that the error for the other state should be equally distributed, so we prefer <span>$\frac{|001\rangle + |010\rangle}{\sqrt{2}}$</span> to <span>$|001\rangle$</span> but the entropy for both of the states is equal. Therefore our loss function is equal to: <span>$-\ln{P(|000\rangle)} + \sum_{i = |001\rangle}^{|111\rangle}P(i)^2$</span> (see <a href="https://github.com/rafal-pracht/OpenScience21.jl/blob/main/04_algorithm_evaluation.ipynb">Algorithm evaluation</a>)</p><p><img src="../../assets/simulation/overview.jpg" alt="image"/></p><p>If the optimal parameters were found, the operator inverse of <em><strong>Ansact</strong></em> transform the initial state into the state after the initialization and the two trotter steps. </p><p>Is worth noting that: if any circuit <em>T</em> transforms the initial state <span>$|000\rangle$</span> into some state <span>$\psi$</span>,  and we find any other <em>A</em> circuit that transforms state <span>$\psi$</span> into the <span>$|000\rangle$</span> one we know that the inverse of the <em>A</em> circuit creates the state <span>$\psi$</span> from state <span>$|000\rangle$</span> with accuracy to global phase (which is irrelevant and can be omitted). Note, that circuits <em>A</em> and <em>T</em> are not equivalent (so they unitary may not and usually are not equal), but this is ok for us we only would like to transform the given input state to the given output. And because these unitaries don&#39;t have to be equal, it is easy to prepare ansact and find the best parameters.</p><p>So the circuits on figure below are equivalent.</p><p><img src="../../assets/simulation/trotter_ansact.png" alt="image"/></p><p>In the Figure below, you can find the ansact with 27 parameters used in the algorithm implementation.</p><p><img src="../../assets/simulation/ansact.jpg" alt="ansact.jpg"/></p><p>It is worth noting:</p><ul><li>We are not looking for parameters that implement the whole unitary matrix of the 2 Trotter steps with the greatest accuracy, but only a transformation for a specific input state. This implies that it is relatively easy to find these parameters. </li><li>Using the ansact, we can replace the circuit with 15 CNOT gates with the one with only 4 CNOT gates.</li><li>I use exactly the same ansact for all iterations but when can have different ansacts for other iterations.</li></ul><h2 id=".1-Next-step"><a class="docs-heading-anchor" href="#.1-Next-step">3.1 Next step</a><a id=".1-Next-step-1"></a><a class="docs-heading-anchor-permalink" href="#.1-Next-step" title="Permalink"></a></h2><p>Then we do a similar step and try to find the parameters <span>$\theta_2$</span> using the gradient descent method that make the circuit in the Figure below will finish at state <span>$|0\rangle_3$</span>.</p><p><img src="../../assets/simulation/overview_next_step.jpg" alt="image"/></p><p>If the optimal parameters <span>$\theta_2$</span> were found, the operator inverse of <em><strong>Ansact</strong></em> transform the initial state into the state after the initialization and the 4 trotter steps. So the circuits on Figure below are equivalent.</p><p><img src="../../assets/simulation/trotter_ansact_next.png" alt="image"/></p><p>By continuing this algorithm finally, we can find the parameters which implement the whole Trotterization, see Figure below.</p><p><img src="../../assets/simulation/overview_final.png" alt="image"/></p><h2 id=".2-Result-evaluation"><a class="docs-heading-anchor" href="#.2-Result-evaluation">3.2 Result evaluation</a><a id=".2-Result-evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#.2-Result-evaluation" title="Permalink"></a></h2><p>I&#39;ve evaluated the algorithm on the simulator with time set to <span>$\frac{\pi}{4}$</span>, <span>$\frac{\pi}{2}$</span>, <span>$\frac{3\pi}{4}$</span>, <span>$\pi$</span> and it works fine. So this show that it will work not only for the special case where the whole circuit is identity. The evaluation can be found in the notebook <a href="https://github.com/rafal-pracht/OpenScience21.jl/blob/main/04_algorithm_evaluation.ipynb">Algorithm evaluation</a></p><h2 id=".3-Trening"><a class="docs-heading-anchor" href="#.3-Trening">3.3 Trening</a><a id=".3-Trening-1"></a><a class="docs-heading-anchor-permalink" href="#.3-Trening" title="Permalink"></a></h2><p>I&#39;ve also find the parameters <span>$\theta_1$</span> of the first step on quantum computer (ibm jakarta).The parameter for steps from 2 to 5 (<span>$\theta_2, \theta_3, \theta_4, \theta_5$</span>) was found on the noisy quantum simulator (as was discussed with AJ). Description of the process of finding the parameter is described in a notebook <a href="https://github.com/rafal-pracht/OpenScience21.jl/blob/main/05_trening.ipynb">QML Trening</a>.</p><h1 id="Execute-on-the-real-device"><a class="docs-heading-anchor" href="#Execute-on-the-real-device">4 Execute on the real device</a><a id="Execute-on-the-real-device-1"></a><a class="docs-heading-anchor-permalink" href="#Execute-on-the-real-device" title="Permalink"></a></h1><p>The whole solution using QuantumCircuits library is available in <a href="https://github.com/rafal-pracht/OpenScience21.jl">GitHub</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../U4_Cartan_decomposition/">« U4 - Cartan&#39;s KAK decomposition</a><a class="docs-footer-nextpage" href="../../QCircuits/Circuit/">Circuit »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.18 on <span class="colophon-date" title="Wednesday 1 June 2022 16:22">Wednesday 1 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
